package org.libserializable.entities.livingentities;

import com.google.gson.JsonObject;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.Nameable;
import org.bukkit.attribute.Attributable;
import org.bukkit.attribute.Attribute;
import org.bukkit.attribute.AttributeInstance;
import org.bukkit.entity.*;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.libserializable.entities.SEntity;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.*;
import java.util.logging.Level;

import com.google.gson.Gson;
import org.libserializable.entities.livingentities.records.*;

/**
 * An internal serializable representation of a living entity
 */
public class SLivingEntity extends SEntity {

    public SLivingEntity(LivingEntity livingEntity) {
        super(livingEntity, SLivingEntity.class);

        Gson gson = new Gson();

        JsonObject serializedEntity = new JsonObject();

        // Serialize type separately since it's an enum
        serializedEntity.add("EntityType", gson.toJsonTree(new SEntityType(entity.getType())));

        // Serialize each interface as a JSON object
        JsonObject attributes = new JsonObject();
        for (Map.Entry<Method, Class<?>> entry : interfaceMethodMap.entrySet()) {
            try {
                if(entry.getKey().getName().startsWith("get")) {
                    Object record = entry.getKey().invoke(this);
                    JsonObject recordJson = gson.toJsonTree(record).getAsJsonObject();
                    attributes.add(entry.getValue().getSimpleName(), recordJson);
                }
            } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
                Bukkit.getLogger().log(Level.WARNING, Arrays.toString(e.getStackTrace()));
            }
        }
        serializedEntity.add("Attributes", attributes);

        this.jsonRepresentation = serializedEntity;
    }

    /**
     * From json, spawns the entity at the specified location
     * @param obj a json object generated by the serializer
     * @param location the location in the world to spawn
     */
    public SLivingEntity(JsonObject obj, Location location) {

        super(Objects.requireNonNull(location.getWorld()).spawnEntity(location, new Gson().fromJson(obj.get("EntityType"), SEntityType.class).type()), LivingEntity.class);

        // Go through all the other attributes and deserialize
        for (Map.Entry<Method, Class<?>> entry : interfaceMethodMap.entrySet()) {
            try {
                if(entry.getKey().getName().startsWith("set")) {
                    entry.getKey().invoke(this);
                }
            } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
                Bukkit.getLogger().log(Level.WARNING, Arrays.toString(e.getStackTrace()));
            }

        }
    }

    /*
        Handled Interfaces Section

        Uses reflection to assign these methods to an interface.
            Each get method should return a serializable value
            Each set method should apply the values passed (Same format as it was given) to a given entity
     */

    /**
     * Ageable interface
     * - int Age
     * - bool isAdult
     * @return SAgeable
     */
    @NotNull
    private SAgeable getAgeable() {
        Ageable ageable = (Ageable)this.entity;
        return new SAgeable(ageable.getAge(), ageable.isAdult());
    }

    private void setAgeable() {
        Ageable ageable = (Ageable)this.entity;
        ageable.setAdult();
    }

    /**
     * Damageable interface
     * - double health
     * - double absorption
     * @return SDamageable
     */
    @NotNull
    private SDamageable getDamageable() {
        Damageable damageable = (Damageable) this.entity;
        return new SDamageable(damageable.getHealth(), damageable.getAbsorptionAmount());
    }

    private void setDamageable() {

    }

    /**
     * Attributable interface
     * - hashmap with values for all non-null attributes
     * @return SAttributable
     */
    @NotNull
    private SAttributable getAttributable() {
        Attributable attributable = (Attributable) entity;
        Map<Attribute, Double> attributes = new HashMap<>();
        // Just load up a map with all the attributes
        for(Attribute attribute : Attribute.values()) {
            AttributeInstance a = attributable.getAttribute(attribute);
            if(a == null) continue;

            attributes.put(attribute, a.getBaseValue());
        }

        return new SAttributable(attributes);
    }

    private void setAttributable() {

    }

    /**
     * Nameable Interface
     * - String name
     *
     * @return SNameable
     */
    @NotNull
    private SNameable getNameable() {
        Nameable nameable = entity;
        return new SNameable(nameable.getCustomName());
    }

    private void setNameable() {

    }

    /**
     * Handles serialization that is not directly handled by an interface (i.e. inventories)
     * @return
     */
//    @Nullable
//    public SEquipment setLivingEntity() {
//        // TODO implement item serialization and deserialization + inventory serialization
////        LivingEntity livingEntity = (LivingEntity) entity;
////        ItemStack[] armourContents = Objects.requireNonNull(livingEntity.getEquipment()).getArmorContents();
////        if(armourContents == null) {
////            return null;
////        } else {
////            return new SEquipment(armourContents);
////        }
//        return null;
//    }

//    public void getLivingEntity() {
//
//    }


}


